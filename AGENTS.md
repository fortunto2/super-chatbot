# Super Chatbot Agents.md Guide for AI Assistants

This Agents.md file provides comprehensive guidance for AI assistants working with the Super Chatbot codebase. The project is built with Next.js 15 App Router, TypeScript, and includes advanced AI capabilities for text, image, and video generation.

## Project Structure for AI Agent Navigation

- `/app`: Next.js App Router structure that AI agents should understand
  - `/(auth)`: Authentication routes and auto-login functionality
  - `/(chat)`: Main chat interface and API routes
  - `/api`: API endpoints for AI agents to interact with
  - `/debug`: Development debugging tools
- `/components`: React components for AI agents to extend
  - `/ui`: Reusable UI components with Radix UI primitives
  - `/artifacts`: Specialized components for rendering AI-generated content
- `/lib`: Core utilities and configurations for AI agents
  - `/ai`: AI SDK integration and tools
  - `/db`: Database schema and migrations
  - `/types`: TypeScript type definitions
  - `/utils`: Helper functions and utilities
- `/hooks`: Custom React hooks for AI agents to utilize
- `/docs`: Documentation that AI agents should reference
- `/tests`: Test files that AI agents should maintain and extend
- `/artifacts`: Generated content storage structure

## AI-Specific Architecture for Agent Understanding

### AI Tools System
AI agents should understand these core tools:
- `create-document`: For creating editable documents
- `update-document`: For modifying existing documents  
- `configure-image-generation`: For FLUX Pro/Dev image generation
- `configure-video-generation`: For SuperDuperAi api (Veo3) video generation
- `get-weather`: For real-time weather data
- `request-suggestions`: For generating contextual suggestions
- `diagnose-styles`: For UI/UX analysis and recommendations

### Artifact Types
AI agents should handle these artifact types:
- `text`: Markdown documents with collaborative editing
- `code`: Syntax-highlighted code with execution capabilities
- `image`: Generated images with FLUX models
- `video`: Generated videos with SuperDuperAi Veo3 model
- `sheet`: Interactive spreadsheets with data manipulation

## Coding Conventions for AI Agents

### General Conventions for Agent Implementation

- Use TypeScript for all code generated by AI agents
- Follow Next.js 15 App Router conventions and best practices
- AI agents should use Server Components by default, Client Components when needed
- All comments and code should be in English, even when communicating in other languages
- Use `"use client"` directive only when necessary for interactivity
- Implement proper error boundaries and error handling

### React Components Guidelines for AI Agents

- AI agents should use Server Components for static content
- Use Client Components for interactive elements with proper `"use client"` directive
- Follow the established component structure in `/components`
- Use Radix UI primitives for accessibility and consistency
- Implement proper TypeScript interfaces for all props
- File naming convention: kebab-case for directories, PascalCase for components

### API Routes Standards for AI Agents

- AI agents should use Next.js App Router API routes (`app/api/**/route.ts`)
- Implement proper authentication middleware checks
- Use Zod for request/response validation
- Follow REST conventions for endpoint design
- Implement proper error handling with standardized error responses
- Use streaming for real-time AI responses

### Styling Standards for AI Agents

- AI agents should use Tailwind CSS for all styling
- Follow utility-first approach consistently
- Use CSS variables for theme customization
- Implement dark/light mode support
- Use Framer Motion for animations when appropriate
- Follow the existing design system patterns

## Database and Storage Guidelines for AI Agents

### Database Operations
AI agents should use Drizzle ORM for database operations:
```typescript
// Example pattern for AI agents
import { db } from '@/lib/db'
import { chats, messages } from '@/lib/db/schema'

// Always use transactions for related operations
await db.transaction(async (tx) => {
  const chat = await tx.insert(chats).values(chatData)
  await tx.insert(messages).values(messageData)
})
```

### File Storage
AI agents should use Vercel Blob for file storage:
```typescript
// Example pattern for AI agents
import { put } from '@vercel/blob'

const blob = await put(filename, file, {
  access: 'public',
  addRandomSuffix: true,
})
```

## AI Integration Patterns for Agents

### Tool Usage Pattern
AI agents should follow this pattern for tool integration:
```typescript
import { tool } from 'ai'
import { z } from 'zod'

export const toolName = tool({
  description: 'Clear description of tool functionality',
  parameters: z.object({
    // Zod schema for validation
  }),
  execute: async (params) => {
    // Tool implementation with proper error handling
  }
})
```

### Streaming Response Pattern
AI agents should implement streaming for real-time responses:
```typescript
// Example streaming implementation
export async function POST(request: Request) {
  const { messages } = await request.json()
  
  const result = await streamText({
    model: openai('gpt-4'),
    messages,
    tools: {
      // Available tools
    }
  })
  
  return result.toAIStreamResponse()
}
```

## Testing Requirements for AI Agents

AI agents should run tests with these commands:

```bash
# Run all tests
pnpm test

# Run specific test file
pnpm test -- tests/specific-test.spec.ts

# Run tests with coverage
pnpm test -- --coverage

# Run E2E tests
pnpm test:e2e
```

### Test Patterns for AI Agents
- Use Playwright for E2E testing of AI interactions
- Test AI tool functionality with mock responses
- Implement proper error case testing
- Test WebSocket connections and streaming

## Development Workflow for AI Agents

### Development Commands
```bash
# Start development server with Turbo
pnpm dev

# Run linting and formatting
pnpm lint
pnpm format

# Database operations
pnpm db:migrate    # Run migrations
pnpm db:studio     # Open database studio
pnpm db:generate   # Generate schema

# Build for production
pnpm build
```

### Code Quality Standards
AI agents should ensure:
- All code passes Biome linting and formatting
- TypeScript strict mode compliance
- Proper error handling and logging
- Accessibility standards compliance
- Performance optimization

## Security Guidelines for AI Agents

### Authentication and Authorization
- Always validate user sessions with NextAuth
- Implement proper rate limiting for AI endpoints
- Use guest authentication for anonymous users
- Validate all inputs with Zod schemas

### Data Validation
```typescript
// Example validation pattern for AI agents
import { z } from 'zod'

const messageSchema = z.object({
  content: z.string().min(1).max(10000),
  chatId: z.string().optional(),
  attachments: z.array(z.object({
    type: z.enum(['image', 'document', 'code']),
    url: z.string().url()
  })).optional()
})
```

## Deployment Guidelines for AI Agents

### Environment Variables
AI agents should be aware of these required environment variables:
- `AUTH_SECRET`: NextAuth secret key
- `POSTGRES_URL`: Database connection string
- `BLOB_READ_WRITE_TOKEN`: Vercel Blob access token
- `AZURE_OPENAI_API_KEY`: Azure OpenAI API key
- `NEXT_PUBLIC_SENTRY_DSN`: Sentry monitoring DSN

### Vercel Deployment
- Use Vercel for optimal Next.js deployment
- Configure proper function timeouts for AI operations
- Set up proper environment variable management
- Enable Sentry monitoring for error tracking

## Error Handling Patterns for AI Agents

### API Error Handling
```typescript
// Standardized error response pattern
interface APIError {
  error: string
  code: number
  details?: any
}

function handleAPIError(error: unknown): APIError {
  if (error instanceof ZodError) {
    return { error: 'Validation error', code: 400, details: error.errors }
  }
  if (error instanceof DatabaseError) {
    return { error: 'Database error', code: 500 }
  }
  return { error: 'Internal server error', code: 500 }
}
```

### Client Error Handling
```typescript
// Error boundary pattern for AI agents
'use client'

export function ErrorBoundary({ children }: { children: React.ReactNode }) {
  return (
    <ErrorBoundaryComponent
      fallback={<ErrorFallback />}
      onError={(error) => {
        console.error('AI Agent Error:', error)
        // Send to monitoring service
      }}
    >
      {children}
    </ErrorBoundaryComponent>
  )
}
```

## Performance Optimization for AI Agents

### Server Components Optimization
- Use Server Components for static content
- Implement proper caching strategies
- Optimize database queries with proper indexing
- Use streaming for AI responses

### Client-Side Optimization
- Implement proper loading states
- Use React Suspense for async components
- Optimize bundle size with dynamic imports
- Implement proper error boundaries

## Monitoring and Observability

### Sentry Integration
AI agents should implement proper error tracking:
```typescript
import * as Sentry from '@sentry/nextjs'

// Track AI operation errors
Sentry.addBreadcrumb({
  category: 'ai-operation',
  message: 'AI tool execution started',
  level: 'info'
})
```

### Performance Monitoring
- Track AI response times
- Monitor database query performance
- Track user interaction metrics
- Monitor error rates and patterns

## Pull Request Guidelines for AI Agents

When AI agents help create PRs, ensure they:

1. Include clear descriptions of AI functionality changes
2. Reference related issues or feature requests
3. Include proper test coverage for AI features
4. Ensure all automated checks pass
5. Include documentation updates for new AI capabilities
6. Test AI tools with various input scenarios
7. Verify WebSocket functionality for real-time features

## Documentation Standards for AI Agents

- Update relevant documentation in `/docs` directory
- Include code examples in documentation
- Document any new AI tools or capabilities
- Keep API documentation current
- Include migration guides for breaking changes

## AI Agent Collaboration Notes

### Multi-Agent Coordination
- Use consistent naming conventions across agents
- Share context through proper documentation
- Implement proper version control for AI-generated content
- Coordinate database schema changes

### Knowledge Sharing
- Document AI tool capabilities and limitations
- Share best practices for AI integration
- Maintain up-to-date architecture documentation
- Coordinate on API design decisions

This Agents.md guide helps ensure AI agents work effectively with the Super Chatbot codebase while maintaining code quality, security, and performance standards. 